<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Function</title>
</head>

<body>

</body>

<script>
  /**
   * Function
   * Function 构造函数 创建一个新的Function对象。 在 JavaScript 中, 每个函数实际上都是一个Function对象。
   * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function
   * 
   * Function构造器生成的函数，在全局作用域中被创建
   */


  /**
   * 属性和方法
   * 全局的Function对象没有自己的属性和方法, 但是, 因为它本身也是函数，所以它也会通过原型链从Function.prototype上继承部分属性和方法。
   */

  // new Function([arg1[, arg2[, ...argN]],]functionBody)

  /**
   * 原型对象
   */

  /** 属性 */
  Function.arguments
  // 以数组形式获取传入函数的所有参数。此属性已被arguments替代。
  Function.caller
  // 获取调用函数的具体对象。
  Function.length
  // 获取函数的接收参数个数。
  Function.name
  // 获取函数的名称。
  Function.displayName
  // 获取函数的display name。
  Function.prototype.constructor
  // 声明函数的原型构造方法，详细请参考 Object.constructor。

  /** 方法 */
  Function.prototype.apply()
  // 在一个对象的上下文中应用另一个对象的方法；参数能够以数组形式传入。
  Function.prototype.bind()
  // bind()方法会创建一个新函数, 称为绑定函数.当调用这个绑定函数时, 绑定函数会以创建它时传入 bind()方法的第一个参数作为 this, 传入 bind()方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数.
  Function.prototype.call()
  // 在一个对象的上下文中应用另一个对象的方法；参数能够以列表形式传入。
  Function.prototype.toString()
  // 获取函数的实现源码的字符串。覆盖了 Object.prototype.toString 方法。
  Function.prototype.isGenerator()  // 非标准
  // 若函数对象为generator，返回true，反之返回 false。
  Function.prototype.toSource()  // 非标准
  // 获取函数的实现源码的字符串。 覆盖了 Object.prototype.toSource 方法。



  /**
   * 实例
   * Function 实例从 Function.prototype 继承了一些属性和方法。 同其他构造函数一样， 你可以改变构造函数的原型从而使得所有的Function实例的属性和方法发生改变。
   */
</script>

</html>