# 浏览器 —— 宏观视角

环境：Chrome

## 打开 1 个页面，有几个进程？

至少有 4 个，浏览器进程、GPU 进程、网络进程、渲染进程。

* 浏览器进程。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
* 渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
* GPU 进程。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。
* 网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
* 插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

## 多进程架构对比之前有什么优点？

2007 年之前，市面上浏览器都是**单进程**的。

单进程问题：

1. 不稳定。一个插件、复杂的 JavaScript 代码的意外崩溃会引起整个浏览器的崩溃。
2. 不流畅。所有页面的渲染模块、JavaScript 执行环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行。不流畅例如无限循环脚本会独占线程、内存泄漏。
3. 不安全。插件可以操作电脑、页面脚本通过浏览器的漏洞来获取系统权限。

多进程架构：

1. 稳定。渲染进程、插件进程 的崩溃不会影响其他进程。
2. 流畅。JavaScript 阻塞了渲染进程不会影响其他页面。内存泄漏问题，在页面关闭后，渲染进程也会被关闭，之后该进程所占用的内存都会被系统回收。
3. 安全。安全沙箱，操作系统给进程上了一把锁。

## TCP协议：如何保证页面文件能被完整送达浏览器？

IP：把数据包送达目的主机。

UDP：把数据包送达应用程序。

IP 通过 IP 地址信息把数据包发送给指定的电脑，而 UDP 通过端口号把数据包分发给正确的程序。

在使用 UDP 发送数据时，有各种因素会导致数据包出错，虽然 UDP 可以校验数据是否正确，但是对于错误的数据包，UDP 并不提供重发机制，只是丢弃当前的包，而且 UDP 在发送之后也无法知道是否能达到目的地。

UDP 不能保证数据可靠性，但是传输速度却非常快

TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。

* 对于数据包丢失的情况，TCP 提供重传机制；
* TCP 引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。

一个完整的 TCP 连接的生命周期包括了 “建立连接” “传输数据” 和 “断开连接” 三个阶段。

传输数据阶段。在该阶段，接收端需要对每个数据包进行确认操作，也就是接收端在接收到数据包之后，需要发送确认数据包给发送端。所以当发送端发送了一个数据包之后，在规定时间内没有接收到接收端反馈的确认消息，则判断为数据包丢失，并触发发送端的重发机制。同样，一个大的文件在传输过程中会被拆分成很多小的数据包，这些数据包到达接收端后，接收端会按照 TCP 头中的序号为其排序，从而保证组成完整的数据。

## 为什么很多站点第二次打开速度会很快？

* 页面资源缓存
* DNS 缓存

![](http://storage.icyc.cc/p/20211028/rc-upload-1635387570473-2.png)

## 从输入 URL 到页面展示，这中间发生了什么？

### 1.用户输入

* 地址栏会判断输入的内容，如果是搜索内容，通过浏览器默认搜索引擎和成新的搜索 URL。
* 标签页上图标进入加载状态。此时页面依然是之前打开的页面内容。

### 2.URL 请求过程

* 浏览器进程会通过进程间通信把 URL 请求发送至网络进程，网络进程开始 URL 请求。
* 网络进程会查找本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给浏览器进程；
* DNS 解析拿到 IP ；
* 如果是 HTTPS ，建立 TLS 链接；
* 利用 IP 地址和服务器三次握手建立 TCP 链接；
* 浏览器构建请求行、请求头等信息，发送给服务端，网络进程接收到服务端发送的响应行、响应头、响应体；
* 如果返回状态码是 301 或 301 ，网络进程会取出响应头 Location 的重定向地址，发起新的请求，重新开始；
* 如果响应头 Content-Type 浏览器不能解析，触发下载；
* 如果类型是 text/html 或能解析，准备渲染进程。

### 3.准备渲染进程

默认情况下，Chrome 会给每个 tab 页分配一个渲染进程。但是如果 A 页面打开 B 页面， B 页面和 A 页面属于同一站点，则 B 页面用 A 页面的渲染进程。判断同一站点的方式是 同协议、同主域。

渲染进程准备好后，浏览器进程告诉渲染进程进入**提交文档阶段**。

### 4.提交文档

* 渲染进程收到“提交文档”消息后，和网络进程建立数据传输的管道；
* 文档传输完成后，渲染进程返回“确认提交”给浏览器进程；
* 浏览器进程收到“确认提交”消息后，更新浏览器状态，包括安全状态、地址栏 RUL 、前进后退历史记录状态，并更新 Web 页面。

### 5.渲染阶段

渲染阶段开始页面解析和子资源加载。

1. 构建 DOM 树。把 HTML 转换为 **DOM 树**结构
2. 样式计算。把 CSS 转换为 **styleSheets** ，转换样式表肿的属性值，计算出 DOM 树中每个节点的具体样式（继承规则、层叠规则），生成 **ComputedStyle** 。
3. 布局阶段。计算出 DOM 树中可见元素的几何位置。1.创建**布局树**，2.布局计算（计算布局树节点的坐标位置）。
4. 分层。渲染引擎为特定节点生成专用的图层，并生成一颗对应的**图层树**。
5. 图层绘制。渲染引擎把图层的绘制拆成很多小的绘制指令，组成一个待**绘制列表**。提交给**合成线程**。
6. 栅格化操作。合成线程将渲染划分为**图块**，视口附近优先生成位图。图块是栅格化执行的最小单位，渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块的位图，并保存在 GPU 的内存中。
7. 合成和显示。一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令，交给浏览器进程，浏览器进程将其页面内容绘制到内存中，最后再将内存显示在屏幕上。

**参考：**

* 浏览器工作原理与实践
