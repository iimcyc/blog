## 多态

同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。换句话说，给不同的对象发送同一个消息的时候，这些对象会根据这个消息分别给出不同的反馈。

## 闭包

> 百度百科：闭包就是能够读取其他函数内部变量的函数。例如在javascript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数“。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。

### 其他理解：

包含被引用变量的对象，闭包存在于嵌套的内部函数中。使用 Chrome 调试 fn.[[Scope]].Closure

 闭包产生的条件：

1. 函数嵌套
2. 内部函数引用了外部函数的数据。

### 误区：闭包会造成内存泄漏

todo..

## 高阶函数

高阶函数是指至少满足下列条件之一的函数。

* 函数可以作为参数被传递;
* 函数可以作为返回值输出。

## 单一职责原则

就一个类而言，应该仅有一个引起它变化的原因。

SRP 原则体现为：一个对象(方法)只做一件事情。

指导我们把对象划分成较小的粒度，这可以提高对象的可复用性。

一方面，如果随着需求的变化，有两个职责总是同时变化，那就不必分离他们。另一方面，职责的变化轴线仅当它们确定会发生变化时才具有意义，即使两个职责已经被耦合在一起，但它们还没有发生改变的征兆，那么也许没有必要主动分离它们，在代码需要重构的时候再进行分离也不迟。

* 优点：降低了单个类或者对象的复杂度，按照职责把对象分解成更小的粒度，这有助于代码的复用，也有利于进行单元测试。当一个职责需要变更的时候，不会影响到其他的职责。
* 缺点：增加编写代码的复杂度。增大了这些对象之间相互联系的难度。

## 最少知识原则

最少知识原则(LKP)说的是 一个软件实体应当尽可能少地与其他实体发生相互作用。

## 开放-封闭原则

软件实体(类、模块、函数)等应该是可以扩展的，但是不可修改。

例如来给 window.onload 函数添加新的功能

```js
Function.prototype.after = function(afterfn) {
  const __self = this
  return function() {
    const ret = __self.apply(this, arguments)
    afterfn.apply(this, arguments)
    return ret
  }
}
window.onload = (window.onload || function() {}).after(function() {
  console.log(document.getElementsByTagName('*').length)
})
```

## 遍历 迭代

遍历：所谓遍历(Traversal)，是指沿着某条搜索路线，依次对树（或图）中每个节点均做一次访问。当然遍历的概念也适合于多元素集合的情况，如数组。






