# HTTP 的发展（0.9 1.0 1.1 2.0）

详情看《浏览器工作原理与实践 - 07 浏览器中的网络》。

## HTTP/0.9 1991 年

- 第一个是只有一个请求行，并没有 HTTP 请求头和请求体，因为只需要一个请求行就可以完整表达客户端的需求了。
- 第二个是服务器也没有返回头信息，这是因为服务器端并不需要告诉客户端太多信息，只需要返回数据就可以了。
- 第三个是返回的文件内容是以 ASCII 字符流来传输的，因为都是 HTML 格式的文件，所以使用 ASCII 字节码来传输是最合适的。

简：

- 只有一个请求行
- 服务器也没有返回头信息
- 返回的文件内容是以 ASCII 字符流来传输

## HTTP/1.0 1996 年

新增：

- 请求头（包含user-agent）、响应头
- 状态码
- Cache 机制

## HTTP/1.1 1997 年

维基百科：

HTTP/1 was finalized and fully documented (as version 1.0) in 1996.[4] It evolved (as version 1.1) in 1997 and then its specifications were updated in 1999, 2014, and 2022.[5]

新增：

- 持久连接
- 请求头加入 Host 字段，支持区分虚拟主机
- 引入 Chunk transfer 机制，支持动态生成的内容
- 新增 cookie

问题：

1. 一个 tcp 通道一次只能处理一个请求，（阻塞）
2. tcp 慢启动，然后慢慢加加速。（慢启动，浪费带宽）
3. 通道间争抢带宽，影响关键资源下载速度（竞争带宽）

### 持久连接

默认开启，Connection: close 关闭，同一域名最多 6 个。

- 1.0 每个请求都经历：建立 tcp 连接->http 请求->http 响应->断开 tcp 连接
- 1.1 持久连接：建立 tcp 连接->http 请求 1->http 响应 1->http 请求 2->http 响应 2....->断开 tcp 连接

### Chunk transfer 机制

- 1.0 响应头中设置完整的数据大小，如 Content-Length: 901
- 1.1 内容可能动态，大小未知。所以分成小块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。

## HTTP/2.0 2015 年

新增：

- 多路复用
- 设置优先级
- 服务器推送
- 头部压缩

### 多路复用

- 一个域名使用一个 tcp 长连接，（解决冷启动）
- 并行请求，随时请求（解决阻塞）

实现：请求和响应添加 ID，加入**二进制分帧层**，拆成很多帧，收到后通过 ID 合并

### 设置优先级

（解决竞争带宽）

发送请求时，设置优先级。由于基于帧传输，所以服务端收到后，暂停之前的请求来优先处理关键资源的请求

### 服务器推送

服务端收到 html 请求后，在浏览器解析出 js css 前，提前把需要的文件推给浏览器。当浏览器解析完 html 后，直接拿到需要的 js css ，这对首次打开页面的速度起到了至关重要的作用。

### 头部压缩

把相同的首部存储起来，仅发送它们之间不同的部分
